"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[525],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return p}});var o=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=o.createContext({}),l=function(e){var t=o.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=l(e.components);return o.createElement(c.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,c=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=l(n),p=r,y=d["".concat(c,".").concat(p)]||d[p]||h[p]||a;return n?o.createElement(y,i(i({ref:t},u),{},{components:n})):o.createElement(y,i({ref:t},u))}));function p(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,i=new Array(a);i[0]=d;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var l=2;l<a;l++)i[l]=n[l];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},89155:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return c},default:function(){return p},frontMatter:function(){return s},metadata:function(){return l},toc:function(){return h}});var o=n(83117),r=n(80102),a=(n(67294),n(3905)),i=["components"],s={},c=void 0,l={unversionedId:"Repo/vsdo",id:"Repo/vsdo",title:"vsdo",description:"Nathaniel",source:"@site/docs/Repo/vsdo.md",sourceDirName:"Repo",slug:"/Repo/vsdo",permalink:"/docs/Repo/vsdo",editUrl:"https://github.com/enarx/enarx.github.io/blob/main/docs/Repo/vsdo.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"ctr0stack",permalink:"/docs/Repo/ctr0stack"},next:{title:"rct1",permalink:"/docs/Repo/rct1"}},u={},h=[],d={toc:h};function p(e){var t=e.components,n=(0,r.Z)(e,i);return(0,a.kt)("wrapper",(0,o.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("iframe",{src:"https://www.youtube.com/embed/OsQfZDmjklE",height:"480",width:"640",allowFullScreen:!0}),(0,a.kt)("hr",null),(0,a.kt)("p",null,"Nathaniel",(0,a.kt)("br",{parentName:"p"}),"\n","So the next one we will look at is the vdso crate. And the vdso crate, I'll also pull up the documentation for that as well. So the vdso crate gives us access to symbols in the virtual dynamic shared object, which is a Linux of functionality. So this is only available on Linux, it's not portable to other operating systems. And what happens is that there are certain ways that the kernel can share information with user space. One of them that we already saw was the crt0stack. But there are other times when the Linux kernel wants to share information with userspace. But it needs to do so and guarantee that userspace is going to run code in a particular way. And so the way that this actually works is that Linux generates on the fly a, a vdso, the virtual dynamic shared object, you can think of this as like a .so library, and it actually injects it into the memory space. And this is at a known location in the user space. And so user space application can actually look up that loaded, dynamic shared object in memory and can resolve symbols from it. And then if those symbols are executable, then you can actually execute this. And so this is a very, very trivial crate. The first method on vdso is the one that creates it. And it's the Locate object, and that just simply finds the vdso in memory, and returns an instance of this vdso struct, which contains a reference to where the vdso is in memory. And then you can look up symbols in the vdso. You look it up by its name, and you get back a reference to the symbol, which is really just a pointer. And you have to cast that to some other type based upon what that symbol name of the symbol is, we can't do that safely for you. But the only thing that this is actually used for in Enarx is for the SGX case. And the reason for this is because when you want to enter an enclave from user space, there's a bunch of really, really tricky code to get right. And so they decided to implement a vdso function for entering an enclave. And so this is used by the SGX code in order to look up that function dynamically at runtime and then execute it. But it is a generic crate, like you can look up. Another interesting symbol in the vdso, for example, is gettime. And the reason for this is that the Linux kernel wants to make it very, very fast for you to get the current time. But if you actually do a context, a full context switch into the kernel, then, you know, you're gonna basically not get time that's as accurate. It'll be a performance overhead. So they actually expose a vdso function for getting the system time where you don't even have to do a context switch. There's a variety of other interesting symbols in the vdso. We don't currently use any of them except for the SGX enclave enter function."))}p.isMDXComponent=!0}}]);