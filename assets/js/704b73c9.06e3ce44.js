"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[232],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return d}});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},f=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),f=c(n),d=a,h=f["".concat(l,".").concat(d)]||f[d]||p[d]||o;return n?r.createElement(h,i(i({ref:t},u),{},{components:n})):r.createElement(h,i({ref:t},u))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=f;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}f.displayName="MDXCreateElement"},19112:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return l},default:function(){return d},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return p}});var r=n(83117),a=n(80102),o=(n(67294),n(3905)),i=["components"],s={},l=void 0,c={unversionedId:"Repo/flagset",id:"Repo/flagset",title:"flagset",description:"Nathaniel",source:"@site/docs/Repo/flagset.md",sourceDirName:"Repo",slug:"/Repo/flagset",permalink:"/docs/Repo/flagset",editUrl:"https://github.com/enarx/enarx.github.io/blob/main/docs/Repo/flagset.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"xsave",permalink:"/docs/Repo/xsave"},next:{title:"sgx",permalink:"/docs/Repo/sgx"}},u={},p=[],f={toc:p};function d(e){var t=e.components,n=(0,a.Z)(e,i);return(0,o.kt)("wrapper",(0,r.Z)({},f,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("iframe",{src:"https://www.youtube.com/embed/yvnSWM3wCko",height:"480",width:"640",allowFullScreen:!0}),(0,o.kt)("hr",null),(0,o.kt)("p",null,"Nathaniel",(0,o.kt)("br",{parentName:"p"}),"\n","Okay, moving on, we'll talk about flagset. flagset is I don't know if we have any actual direct dependencies of flagset, but I have added flagset as a dependency to the Rust crypto project. And so you may be familiar with the bitflags crate or the enumflags crate. And both of those crates had significant downsides, which I talked about in the existing implementations. And the, we basically implemented a new implementation of this, which doesn't have all the downsides. For example, we don't have procedural macros, which requires additional dependencies, and then increases your compile time. And we just do this instead of with regular macros. And on the other hand, we don't have problems like enumflags, for example, does not allow you to describe the size of the flags in a way that's binary compatible, particularly across aliasing. So like we support that ability. They're basically a bunch of hardware level features. The crate itself is fairly ergonomic to use, it's very well tested. And the way we're using it in the Rust crypto project is that we are any of the flags that are described in asn1. We have blank implementations of encoding and decoding from the asn1 values into flag set values. And then we have an ergonomic API to test bit flags basically. So this crate is actually used a variety of places. The crate is actually one of the first crates I ever wrote. So it's quite old. It's three or four years old, I think at this point."))}d.isMDXComponent=!0}}]);