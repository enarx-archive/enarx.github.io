"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2005],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return d}});var r=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=r.createContext({}),l=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),h=l(n),d=o,y=h["".concat(c,".").concat(d)]||h[d]||p[d]||a;return n?r.createElement(y,i(i({ref:t},u),{},{components:n})):r.createElement(y,i({ref:t},u))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=h;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var l=2;l<a;l++)i[l]=n[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},41552:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return c},default:function(){return d},frontMatter:function(){return s},metadata:function(){return l},toc:function(){return p}});var r=n(83117),o=n(80102),a=(n(67294),n(3905)),i=["components"],s={},c=void 0,l={unversionedId:"Repo/lset",id:"Repo/lset",title:"lset",description:"Nathaniel",source:"@site/docs/Repo/lset.md",sourceDirName:"Repo",slug:"/Repo/lset",permalink:"/docs/Repo/lset",editUrl:"https://github.com/enarx/enarx.github.io/blob/main/docs/Repo/lset.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"noted",permalink:"/docs/Repo/noted"},next:{title:"nbytes",permalink:"/docs/Repo/nbytes"}},u={},p=[],h={toc:p};function d(e){var t=e.components,n=(0,o.Z)(e,i);return(0,a.kt)("wrapper",(0,r.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("iframe",{src:"https://www.youtube.com/embed/E0nt7t7cD7Q",height:"480",width:"640",allowFullScreen:!0}),(0,a.kt)("hr",null),(0,a.kt)("p",null,"Nathaniel",(0,a.kt)("br",{parentName:"p"}),"\n","Okay, the next crate is called lset, which is data types for describing linear sets. And this is another one of those crates that we used a lot early on. And this one still does have some value, compared to primordial, although again, I don't know that we've been using it as much now as we used to use it. And basically what it is, is, these are two types line and span. And they're basically they're isomorphic with the range type. So if you know the range type in the standard Rust standard library, they're isomorphic with that. A line defines a linear array by a start point and an end point, right. So you have like the pointer of the start and the pointer to the end. And everything that's between is included in that set. The span is exactly the same thing, except it's defined as a start point and account rather than the start point and the end point. One other important thing that this does, that the range type does not do is that range does not copy, does not implement copy, which means that there's a variety of situations where it's really annoying to use. And the reason for that is that range is an iterator but these types are not iterators. Iterators can't be copy, because otherwise you may accidentally make a copy of the iterator and now you have two iterators, that you're iterating over. So it's not copy. These types are copy. But again, they're not bad if you want to use this in new code, I don't mind, but we also sort of haven't been really been using it as much. It's still probably useful. Great. But yeah."))}d.isMDXComponent=!0}}]);