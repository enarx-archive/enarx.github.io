"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2820],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return f}});var o=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=o.createContext({}),u=function(e){var t=o.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=u(e.components);return o.createElement(c.Provider,{value:t},e.children)},l={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},h=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,c=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),h=u(n),f=a,y=h["".concat(c,".").concat(f)]||h[f]||l[f]||r;return n?o.createElement(y,i(i({ref:t},d),{},{components:n})):o.createElement(y,i({ref:t},d))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=h;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var u=2;u<r;u++)i[u]=n[u];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}h.displayName="MDXCreateElement"},72365:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return c},default:function(){return f},frontMatter:function(){return s},metadata:function(){return u},toc:function(){return l}});var o=n(83117),a=n(80102),r=(n(67294),n(3905)),i=["components"],s={},c=void 0,u={unversionedId:"Repo/noted",id:"Repo/noted",title:"noted",description:"Nathaniel",source:"@site/docs/Repo/noted.md",sourceDirName:"Repo",slug:"/Repo/noted",permalink:"/docs/Repo/noted",editUrl:"https://github.com/enarx/enarx.github.io/blob/main/docs/Repo/noted.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"iocuddle",permalink:"/docs/Repo/iocuddle"},next:{title:"lset",permalink:"/docs/Repo/lset"}},d={},l=[],h={toc:l};function f(e){var t=e.components,n=(0,a.Z)(e,i);return(0,r.kt)("wrapper",(0,o.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("iframe",{src:"https://www.youtube.com/embed/C52YePpNJxw",height:"480",width:"640",allowFullScreen:!0}),(0,r.kt)("hr",null),(0,r.kt)("p",null,"Nathaniel",(0,r.kt)("br",{parentName:"p"}),"\n","noted is used primarily in our shims. And what noted does is there's a feature in elf binaries called notes. And basically what this means is that you can define a note. And a note contains some data type, usually, you know, a combination of integers of different sizes, and they have names. And it allows you to record information in the elf binary that can be used by tools that process that binary. So it's basically just metadata. And we originally tried to do this by using standard tools to add notes to binaries after the build. But what we realized pretty quickly was that cargo does not really allow any way to modify a binary after the build. And so we needed to come up with another way to do this. And so this is what we came up with, is this crate called noded. And inside of this noded macro, you have to define what section you want those notes to be in. And the reason you have to define it is because it's incredibly common to use custom sections. So even though we could have theoretically come up with a default, it's far more common to use a custom section. So we just said, you know, let's just be explicit about it rather than implicit. And you have to specify that. But then once you specify the section where you want the notes to be defined, then you define notes using this syntax. And basically, you're defining this variable foo. And you know, it's going to have a name, which is a bunch of x's. And it's a one, which means, that's the number of the notes. So notes have names and numbers. And then we define the type of that note, and then the value of that note, and basically, this macro just generates a bunch of code, and then the specified notes end up in the binary, and then that can be parsed. And I'll actually show you where this is used. So we're now in the main Enarx repo, and I'm going into the SGX shim. And if you look in the main section, at the top of the main section, there are a bunch of notes that we've defined here. And basically these notes communicate to... the shim is loaded into an enclave by the Enarx run command. The Enarx run command looks at the binary, and reads all the notes. And it defines things like what's the size of the enclave? We can define how many SSA areas we want. We talked about that yesterday, how you can enter an enclave sort of recursively and you can have multiple SSAs. So you can define here how many of those you want. The important thing is that we need to be able to access these variables inside of the enclave as compiler constants, essentially, but they also need to be communicated to the loader to know how many to load. And if the loader chooses not to respect these options, we will get a different measurement of the code during attestation. So we can't detect at runtime, but we can detect at attestation time whether or not those defaults have been correctly followed or not. So it ends up being safe in the end. It's basically a kind of key value store as metadata in the binary where you can communicate to tools that are processing the binary and various ways."))}f.isMDXComponent=!0}}]);